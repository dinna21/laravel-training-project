{"version":3,"file":"index-CMWG4mbA.js","sources":["../../../resources/js/wayfinder/index.ts"],"sourcesContent":["export type QueryParams = Record<\n    string,\n    | string\n    | number\n    | boolean\n    | string[]\n    | null\n    | undefined\n    | Record<string, string | number | boolean>\n>;\n\ntype Method = \"get\" | \"post\" | \"put\" | \"delete\" | \"patch\" | \"head\" | \"options\";\n\nlet urlDefaults: Record<string, unknown> = {};\n\nexport type RouteDefinition<TMethod extends Method | Method[]> = {\n    url: string;\n} & (TMethod extends Method[] ? { methods: TMethod } : { method: TMethod });\n\nexport type RouteFormDefinition<TMethod extends Method> = {\n    action: string;\n    method: TMethod;\n};\n\nexport type RouteQueryOptions = {\n    query?: QueryParams;\n    mergeQuery?: QueryParams;\n};\n\nexport const queryParams = (options?: RouteQueryOptions) => {\n    if (!options || (!options.query && !options.mergeQuery)) {\n        return \"\";\n    }\n\n    const query = options.query ?? options.mergeQuery;\n    const includeExisting = options.mergeQuery !== undefined;\n\n    const getValue = (value: string | number | boolean) => {\n        if (value === true) {\n            return \"1\";\n        }\n\n        if (value === false) {\n            return \"0\";\n        }\n\n        return value.toString();\n    };\n\n    const params = new URLSearchParams(\n        includeExisting && typeof window !== \"undefined\"\n            ? window.location.search\n            : \"\",\n    );\n\n    for (const key in query) {\n        if (query[key] === undefined || query[key] === null) {\n            params.delete(key);\n            continue;\n        }\n\n        if (Array.isArray(query[key])) {\n            if (params.has(`${key}[]`)) {\n                params.delete(`${key}[]`);\n            }\n\n            query[key].forEach((value) => {\n                params.append(`${key}[]`, value.toString());\n            });\n        } else if (typeof query[key] === \"object\") {\n            params.forEach((_, paramKey) => {\n                if (paramKey.startsWith(`${key}[`)) {\n                    params.delete(paramKey);\n                }\n            });\n\n            for (const subKey in query[key]) {\n                if (typeof query[key][subKey] === \"undefined\") {\n                    continue;\n                }\n\n                if (\n                    [\"string\", \"number\", \"boolean\"].includes(\n                        typeof query[key][subKey],\n                    )\n                ) {\n                    params.set(\n                        `${key}[${subKey}]`,\n                        getValue(query[key][subKey]),\n                    );\n                }\n            }\n        } else {\n            params.set(key, getValue(query[key]));\n        }\n    }\n\n    const str = params.toString();\n\n    return str.length > 0 ? `?${str}` : \"\";\n};\n\nexport const setUrlDefaults = (params: Record<string, unknown>) => {\n    urlDefaults = params;\n};\n\nexport const addUrlDefault = (\n    key: string,\n    value: string | number | boolean,\n) => {\n    urlDefaults[key] = value;\n};\n\nexport const applyUrlDefaults = <T extends Record<string, unknown> | undefined>(\n    existing: T,\n): T => {\n    const existingParams = { ...(existing ?? ({} as Record<string, unknown>)) };\n\n    for (const key in urlDefaults) {\n        if (\n            existingParams[key] === undefined &&\n            urlDefaults[key] !== undefined\n        ) {\n            (existingParams as Record<string, unknown>)[key] = urlDefaults[key];\n        }\n    }\n\n    return existingParams as T;\n};\n\nexport const validateParameters = (\n    args: Record<string, unknown> | undefined,\n    optional: string[],\n) => {\n    const missing = optional.filter((key) => !args?.[key]);\n    const expectedMissing = optional.slice(missing.length * -1);\n\n    for (let i = 0; i < missing.length; i++) {\n        if (missing[i] !== expectedMissing[i]) {\n            throw Error(\n                \"Unexpected optional parameters missing. Unable to generate a URL.\",\n            );\n        }\n    }\n};\n"],"names":["urlDefaults","queryParams","options","query","includeExisting","getValue","value","params","key","_","paramKey","subKey","str","applyUrlDefaults","existing","existingParams"],"mappings":"AAaA,IAAIA,EAAuC,CAAA,EAgBpC,MAAMC,EAAeC,GAAgC,CACxD,GAAI,CAACA,GAAY,CAACA,EAAQ,OAAS,CAACA,EAAQ,WACxC,MAAO,GAGX,MAAMC,EAAQD,EAAQ,OAASA,EAAQ,WACjCE,EAAkBF,EAAQ,aAAe,OAEzCG,EAAYC,GACVA,IAAU,GACH,IAGPA,IAAU,GACH,IAGJA,EAAM,SAAA,EAGXC,EAAS,IAAI,gBACfH,GAAmB,OAAO,OAAW,IAC/B,OAAO,SAAS,OAChB,EAAA,EAGV,UAAWI,KAAOL,EAAO,CACrB,GAAIA,EAAMK,CAAG,IAAM,QAAaL,EAAMK,CAAG,IAAM,KAAM,CACjDD,EAAO,OAAOC,CAAG,EACjB,QACJ,CAEA,GAAI,MAAM,QAAQL,EAAMK,CAAG,CAAC,EACpBD,EAAO,IAAI,GAAGC,CAAG,IAAI,GACrBD,EAAO,OAAO,GAAGC,CAAG,IAAI,EAG5BL,EAAMK,CAAG,EAAE,QAASF,GAAU,CAC1BC,EAAO,OAAO,GAAGC,CAAG,KAAMF,EAAM,UAAU,CAC9C,CAAC,UACM,OAAOH,EAAMK,CAAG,GAAM,SAAU,CACvCD,EAAO,QAAQ,CAACE,EAAGC,IAAa,CACxBA,EAAS,WAAW,GAAGF,CAAG,GAAG,GAC7BD,EAAO,OAAOG,CAAQ,CAE9B,CAAC,EAED,UAAWC,KAAUR,EAAMK,CAAG,EACtB,OAAOL,EAAMK,CAAG,EAAEG,CAAM,EAAM,KAK9B,CAAC,SAAU,SAAU,SAAS,EAAE,SAC5B,OAAOR,EAAMK,CAAG,EAAEG,CAAM,CAAA,GAG5BJ,EAAO,IACH,GAAGC,CAAG,IAAIG,CAAM,IAChBN,EAASF,EAAMK,CAAG,EAAEG,CAAM,CAAC,CAAA,CAI3C,MACIJ,EAAO,IAAIC,EAAKH,EAASF,EAAMK,CAAG,CAAC,CAAC,CAE5C,CAEA,MAAMI,EAAML,EAAO,SAAA,EAEnB,OAAOK,EAAI,OAAS,EAAI,IAAIA,CAAG,GAAK,EACxC,EAaaC,EACTC,GACI,CACJ,MAAMC,EAAiB,CAAE,GAAID,GAAa,EAAC,EAE3C,UAAWN,KAAOR,EAEVe,EAAeP,CAAG,IAAM,QACxBR,EAAYQ,CAAG,IAAM,SAEpBO,EAA2CP,CAAG,EAAIR,EAAYQ,CAAG,GAI1E,OAAOO,CACX"}